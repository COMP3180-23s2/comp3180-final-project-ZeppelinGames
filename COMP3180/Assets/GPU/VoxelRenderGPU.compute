// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct Voxel {
    float3 position;
};

struct VoxelShape {
    uint numVertices;
    uint numNormals;
    uint numFaces;
    uint padding;

    Buffer<float3> verts;
    Buffer<float3> norms;

    // int[][]. Access accordingly [y * numFaces + x]
    Buffer<int3> tris;
};

StructuredBuffer<Voxel> _Voxels;
StructuredBuffer<VoxelShape> _VoxelShape;

struct GeneratedVertex {
    float3 position;
    float3 normal;
};

RWStructuredBuffer<GeneratedVertex> _GeneratedVeritices;
RWStructuredBuffer<int> _GeneratedIndices;

int _NumSourceTriangles

[numthreads(32, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID,
    RWStructuredBuffer<float3> vOut,
    RWStructuredBuffer<int> tOut,
    RWStructuredBuffer<float3> nOut,
    RWStructuredBuffer<float4> cOut)
{
    // TODO: insert actual code here!
    
    // Dont want more threads than triangles
    if ((int)id.x >= _NumSourceTriangles) {
        return;
    }

    int triStart = id.x * 3;
    int vertStart = id.x * _VoxelShape.verts.Length;
    for (int j = 0; j < _VoxelShape.verts.Length; j++)
    {
        _GeneratedVerticies[idx + j] = _VoxelShape.verts[j];
    }

    _GeneratedTris[triStart] = 0;
    _GeneratedTris[triStart + 1] = 1;
    _GeneratedTris[triStart + 2] = 2;

    Voxel v = _Voxels[id.x];
}
